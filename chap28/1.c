//早期通过开关中断实现锁
//优点就是简单
//缺点:
//1.要求我们允许所有调用线程执行特权操作（打开关闭中断），即信任这种机制不会被滥用。众所周知，如果我们必须信任任意一个程序，
//可能就有麻烦了。这里，麻烦表现为多种形式：第一，一个贪婪的程序可能在它开始时就调用lock()，从而独占处理器。
//更糟的情况是，恶意程序调用lock()后，一直死循环。后一种情况，系统无法重新获得控制，只能重启系统。关闭中断对应用要求太多，
//不太适合作为通用的同步解决方案。
//2.不支持多处理器。如果多个线程运行在不同的CPU上，每个线程都试图进入同一个临界区，关闭中断也没有作用。
//线程可以运行在其他处理器上，因此能够进入临界区。
//3.关闭中断导致中断丢失，可能会导致严重的系统问题。假如磁盘设备完成了读取请求，但CPU错失了这一事实，
//那么，操作系统如何知道去唤醒等待读取的进程？
//4.效率低。与正常指令执行相比，现代CPU对于关闭和打开中断的代码执行得较慢。

void lock() {
  DisableInterrupts();
}
void unlock() {
  EnableInterrupts();
}